// src/monitoring/service.rs
use tokio::sync::RwLock;
use std::sync::Arc;
<<<<<<< HEAD
use std::collections::HashMap;
use chrono::Utc;
use super::collector::MetricsCollector;
use crate::models::metrics::ServerMetrics;
use crate::db::models::MetricsSnapshot;
use crate::db::repository::Repository;
=======
use crate::models::metrics::{ServerMetrics, ProcessMetrics};
use crate::db::Repository;
>>>>>>> d18e561ecf6f553bddd2ea81a6fbdc848ce1417d

pub struct MonitoringService {
    collector: Arc<RwLock<MetricsCollector>>,
    repository: Repository,
<<<<<<< HEAD
    metrics_cache: Arc<RwLock<HashMap<String, ServerMetrics>>>,
=======
>>>>>>> d18e561ecf6f553bddd2ea81a6fbdc848ce1417d
}

impl MonitoringService {
    pub fn new(repository: Repository) -> Self {
        let collector = MetricsCollector::new();
        let service = Self {
            collector: Arc::new(RwLock::new(collector)),
            repository,
<<<<<<< HEAD
            metrics_cache: Arc::new(RwLock::new(HashMap::new())),
=======
>>>>>>> d18e561ecf6f553bddd2ea81a6fbdc848ce1417d
        };
        
        service.clone().start();
        service
    }

    pub fn clone(&self) -> Self {
        Self {
            collector: Arc::clone(&self.collector),
            repository: self.repository.clone(),
<<<<<<< HEAD
            metrics_cache: Arc::clone(&self.metrics_cache),
=======
>>>>>>> d18e561ecf6f553bddd2ea81a6fbdc848ce1417d
        }
    }

    async fn start(self) {
<<<<<<< HEAD
        tokio::spawn(async move {
            loop {
                self.collect_and_store_metrics().await;
                tokio::time::sleep(tokio::time::Duration::from_secs(60)).await;
            }
        });
    }

    async fn collect_and_store_metrics(&self) {
        if let Some(system_metrics) = self.collector.read().await.get_current_metrics().await {
            let servers = match self.repository.list_servers().await {
                Ok(servers) => servers,
                Err(e) => {
                    eprintln!("Failed to get servers list: {}", e);
                    return;
                }
            };

            let mut metrics_cache = self.metrics_cache.write().await;
            
            for server in servers {
                let server_metrics = ServerMetrics {
                    server_id: server.id.clone(),
                    hostname: server.hostname,
                    cpu_usage: system_metrics.cpu_usage,
                    memory_usage: system_metrics.memory_usage,
                    disk_usage: system_metrics.disk_usage,
                    network_rx: system_metrics.network_rx,
                    network_tx: system_metrics.network_tx,
                    processes: system_metrics.processes.clone(),
                    timestamp: Utc::now(),
                };

                // Store in database
                let snapshot = MetricsSnapshot {
                    id: 0, // Auto-generated by DB
                    server_id: server.id.clone(),
                    cpu_usage: system_metrics.cpu_usage,
                    memory_usage: system_metrics.memory_usage,
                    disk_usage: system_metrics.disk_usage,
                    network_rx: system_metrics.network_rx,
                    network_tx: system_metrics.network_tx,
                    processes: system_metrics.processes.clone(),
                    timestamp: Utc::now(),
                };

                if let Err(e) = self.repository.save_metrics_snapshot(&snapshot).await {
                    eprintln!("Failed to save metrics for server {}: {}", server.id, e);
                }

                // Update cache
                metrics_cache.insert(server.id, server_metrics);
            }
        }
    }

    pub async fn get_current_metrics(&self) -> Option<Vec<ServerMetrics>> {
        let cache = self.metrics_cache.read().await;
        if cache.is_empty() {
            None
        } else {
            Some(cache.values().cloned().collect())
        }
    }

    pub async fn get_server_metrics(&self, server_id: &str) -> Option<ServerMetrics> {
        self.metrics_cache.read().await.get(server_id).cloned()
    }

    pub async fn get_server_processes(&self, server_id: &str) -> Option<serde_json::Value> {
        self.get_server_metrics(server_id).await
            .map(|metrics| metrics.processes)
    }

    pub async fn get_historical_metrics(
        &self,
        server_id: &str,
        from: chrono::DateTime<Utc>,
        to: chrono::DateTime<Utc>,
    ) -> Result<Vec<MetricsSnapshot>, sqlx::Error> {
        self.repository.get_metrics_history(server_id, from, to).await
    }

    pub async fn get_alerts(&self, server_id: &str) -> Result<Vec<crate::db::models::Alert>, sqlx::Error> {
        self.repository.get_server_alerts(server_id).await
    }

    pub async fn check_alerts(&self) {
        if let Some(metrics_list) = self.get_current_metrics().await {
            for metrics in metrics_list {
                // CPU 사용량 경고
                if metrics.cpu_usage > 90.0 {
                    self.create_alert(
                        &metrics.server_id,
                        "high_cpu",
                        crate::db::models::AlertSeverity::Critical,
                        &format!("High CPU usage: {}%", metrics.cpu_usage)
                    ).await;
                } else if metrics.cpu_usage > 80.0 {
                    self.create_alert(
                        &metrics.server_id,
                        "high_cpu",
                        crate::db::models::AlertSeverity::Warning,
                        &format!("Elevated CPU usage: {}%", metrics.cpu_usage)
                    ).await;
                }

                // 메모리 사용량 경고
                if metrics.memory_usage > 90.0 {
                    self.create_alert(
                        &metrics.server_id,
                        "high_memory",
                        crate::db::models::AlertSeverity::Critical,
                        &format!("High memory usage: {}%", metrics.memory_usage)
                    ).await;
                } else if metrics.memory_usage > 80.0 {
                    self.create_alert(
                        &metrics.server_id,
                        "high_memory",
                        crate::db::models::AlertSeverity::Warning,
                        &format!("Elevated memory usage: {}%", metrics.memory_usage)
                    ).await;
                }

                // 디스크 사용량 경고
                if metrics.disk_usage > 90.0 {
                    self.create_alert(
                        &metrics.server_id,
                        "high_disk",
                        crate::db::models::AlertSeverity::Critical,
                        &format!("High disk usage: {}%", metrics.disk_usage)
                    ).await;
                } else if metrics.disk_usage > 80.0 {
                    self.create_alert(
                        &metrics.server_id,
                        "high_disk",
                        crate::db::models::AlertSeverity::Warning,
                        &format!("Elevated disk usage: {}%", metrics.disk_usage)
                    ).await;
                }
            }
        }
    }

    async fn create_alert(
        &self,
        server_id: &str,
        alert_type: &str,
        severity: crate::db::models::AlertSeverity,
        message: &str,
    ) {
        let alert = crate::db::models::Alert {
            id: 0, // Auto-generated by DB
            server_id: server_id.to_string(),
            alert_type: alert_type.to_string(),
            severity,
            message: message.to_string(),
            created_at: Utc::now(),
            acknowledged_at: None,
            acknowledged_by: None,
        };

        if let Err(e) = self.repository.create_alert(&alert).await {
            eprintln!("Failed to create alert for server {}: {}", server_id, e);
        }
    }
}

pub mod metrics {
    use chrono::{DateTime, Utc};
    use serde::{Deserialize, Serialize};
    use serde_json::Value as JsonValue;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct ServerMetrics {
        pub server_id: String,
        pub hostname: String,
        pub cpu_usage: f32,
        pub memory_usage: f32,
        pub disk_usage: f32,
        pub network_rx: i64,
        pub network_tx: i64,
        pub processes: JsonValue,
        pub timestamp: DateTime<Utc>,
    }
=======
        let collector = self.collector.write().await;
        collector.start_collection().await;
    }

    pub async fn get_current_metrics(&self) -> Option<ServerMetrics> {
        self.collector.read().await.get_current_metrics().await
    }
    
    // Add more methods...
>>>>>>> d18e561ecf6f553bddd2ea81a6fbdc848ce1417d
}